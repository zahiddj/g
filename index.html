<!DOCTYPE html>
<html>
<head>
    <title>Memory Quest - Verified Advanced Version</title>
    <style>
        * { margin: 0; padding: 0; }
        body { overflow: hidden; }
        #hud {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #fff;
            font-family: Arial;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 1000;
        }
        #debug {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: #0f0;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div id="hud">
        <div>Memories: <span id="score">0</span>/12</div>
        <div>FPS: <span id="fps">0</span></div>
    </div>
    <div id="debug">Initializing...</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
'use strict';

class MemoryQuest {
    constructor() {
        this.initState = {
            threejs: false,
            renderer: false,
            scene: false,
            camera: false,
            controls: false
        };
        
        try {
            this.initializeEngine();
            this.createScene();
            this.setupGameSystems();
            this.setupDebugging();
            this.animate();
        } catch (error) {
            this.showFatalError(error);
        }
    }

    initializeEngine() {
        // 1. Three.js Core
        if(!THREE) throw new Error('Three.js failed to load');
        this.initState.threejs = true;

        // 2. Renderer
        this.renderer = new THREE.WebGLRenderer({
            antialias: true,
            powerPreference: "high-performance"
        });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(this.renderer.domElement);
        this.initState.renderer = true;

        // 3. Scene
        this.scene = new THREE.Scene();
        this.initState.scene = true;

        // 4. Camera
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        this.camera.position.set(0, 5, 10);
        this.initState.camera = true;

        // 5. Lighting
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(0, 10, 10);
        light.castShadow = true;
        this.scene.add(light);
        this.scene.add(new THREE.AmbientLight(0x404040));
    }

    createScene() {
        // Ground
        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(100, 100),
            new THREE.MeshStandardMaterial({ color: 0x3c8f3c })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        this.scene.add(ground);

        // Player
        this.player = new THREE.Mesh(
            new THREE.CapsuleGeometry(0.5, 1.5, 8, 16),
            new THREE.MeshStandardMaterial({ color: 0xff4444 })
        );
        this.player.castShadow = true;
        this.player.position.y = 1.5;
        this.scene.add(this.player);

        // Collectibles
        this.collectibles = [];
        for(let i = 0; i < 12; i++) {
            const memory = new THREE.Mesh(
                new THREE.IcosahedronGeometry(0.5, 3),
                new THREE.MeshStandardMaterial({
                    color: 0xFFD700,
                    emissive: 0xFFD700,
                    emissiveIntensity: 0.5
                })
            );
            memory.position.set(
                Math.random() * 40 - 20,
                1,
                Math.random() * 40 - 20
            );
            memory.castShadow = true;
            this.collectibles.push(memory);
            this.scene.add(memory);
        }
    }

    setupGameSystems() {
        // Controls
        this.velocity = new THREE.Vector3();
        this.moveSpeed = 5;
        document.addEventListener('keydown', (e) => this.handleInput(e, true));
        document.addEventListener('keyup', (e) => this.handleInput(e, false));

        // Collision Configuration
        this.raycaster = new THREE.Raycaster();
        this.collisionObjects = this.collectibles;
    }

    handleInput(event, isPressed) {
        const keyState = {
            'w': 'forward',
            's': 'backward',
            'a': 'left',
            'd': 'right'
        }[event.key.toLowerCase()];

        if(keyState) this[keyState] = isPressed;
    }

    updatePlayer(delta) {
        this.velocity.set(0, 0, 0);
        
        if(this.forward) this.velocity.z = -this.moveSpeed;
        if(this.backward) this.velocity.z = this.moveSpeed;
        if(this.left) this.velocity.x = -this.moveSpeed;
        if(this.right) this.velocity.x = this.moveSpeed;
        
        this.player.position.add(this.velocity.multiplyScalar(delta));
        this.player.position.clamp(
            new THREE.Vector3(-40, 0.5, -40),
            new THREE.Vector3(40, 10, 40)
        );
    }

    checkCollisions() {
        this.collectibles.forEach((mem, index) => {
            if(mem.position.distanceTo(this.player.position) < 1.5) {
                this.scene.remove(mem);
                this.collectibles.splice(index, 1);
                document.getElementById('score').textContent = 12 - this.collectibles.length;
            }
        });
    }

    setupDebugging() {
        // FPS Counter
        this.fps = 0;
        this.lastFrame = performance.now();
        
        // Debug Info Updater
        setInterval(() => {
            const debugInfo = [
                `Three.js: ${this.initState.threejs ? 'OK' : 'FAIL'}`,
                `Renderer: ${this.initState.renderer ? 'OK' : 'FAIL'}`,
                `Scene: ${this.initState.scene ? 'OK' : 'FAIL'}`,
                `Camera: ${this.initState.camera ? 'OK' : 'FAIL'}`,
                `FPS: ${this.fps.toFixed(1)}`,
                `Player Position: ${this.player.position.toArray().map(v => v.toFixed(1))}`
            ].join('\n');
            
            document.getElementById('debug').textContent = debugInfo;
        }, 100);
    }

    animate() {
        const now = performance.now();
        const delta = (now - this.lastFrame) / 1000;
        this.lastFrame = now;
        this.fps = 1 / delta;

        try {
            this.updatePlayer(delta);
            this.checkCollisions();
            this.renderer.render(this.scene, this.camera);
        } catch (error) {
            this.showFatalError(error);
            return;
        }

        requestAnimationFrame(() => this.animate());
    }

    showFatalError(error) {
        document.body.innerHTML = `
            <div style="color: red; padding: 20px; font-family: monospace;">
                <h2>Critical Error</h2>
                <pre>${error.stack}</pre>
                <p>Init State: ${JSON.stringify(this.initState, null, 2)}</p>
            </div>
        `;
    }
}

// Start Game with Error Protection
try {
    new MemoryQuest();
} catch (error) {
    document.body.innerHTML = `<h1 style="color: red;">Fatal Error: ${error.message}</h1>`;
}
</script>
</body>
</html>
